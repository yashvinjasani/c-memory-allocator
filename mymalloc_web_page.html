<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Efficient Memory Allocation in C - Yashvin Jasani</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <!-- Include the TCC-JS compiler library -->
    <script src="https://cdn.jsdelivr.net/npm/tcc-js@0.0.12/dist/tcc-js.js"></script>
    <style>
        :root {
            --primary-color: #4A90E2;
            --primary-hover: #357ABD;
            --bg-color: #F5F7FA;
            --section-bg: #ffffff;
            --text-color: #4A4A4A;
            --heading-color: #2c3e50;
            --border-color: #E4E7EB;
            --code-bg: #282c34;
            --code-text: #abb2bf;
        }
        html { scroll-behavior: smooth; }
        body { font-family: 'Roboto', sans-serif; line-height: 1.7; margin: 0; padding: 0; background-color: var(--bg-color); color: var(--text-color); }
        .container { max-width: 1200px; margin: auto; padding: 0 2rem; }
        h1, h2, h3, h4 { font-family: 'Poppins', sans-serif; color: var(--heading-color); font-weight: 600; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        header { background: var(--section-bg); padding: 3rem 0; text-align: center; border-bottom: 1px solid var(--border-color); overflow: hidden; }
        header h1 { margin: 0; font-size: 3rem; font-weight: 700; color: var(--heading-color); animation: fadeInUp 0.8s ease-out both; }
        header p { margin: 0.5rem 0 0; font-size: 1.25rem; color: #7f8c9b; animation: fadeInUp 0.8s ease-out 0.2s both; }
        .section { background: var(--section-bg); margin: 2.5rem 0; padding: 3rem; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.07); border: 1px solid var(--border-color); }
        .fade-in-section { opacity: 0; transform: translateY(30px); transition: opacity 0.6s ease-out, transform 0.6s ease-out; }
        .fade-in-section.is-visible { opacity: 1; transform: translateY(0); }
        .section h2 { font-size: 2.2rem; color: var(--primary-color); border-bottom: 2px solid var(--border-color); padding-bottom: 1rem; margin-top: 0; margin-bottom: 2rem; }
        .overview-section .content-wrapper { max-width: 800px; margin: 0 auto; }
        .overview-section p { margin-bottom: 1.25rem; font-size: 1.1rem; }
        .overview-section h3 { color: var(--heading-color); margin-top: 2rem; font-size: 1.6rem; }
        .test-desc { border-left: 4px solid var(--primary-color); padding: 1.5rem; margin: 1.5rem 0; background-color: #f8f9fa; border-radius: 0 8px 8px 0; }
        .test-desc h4 { margin: 0 0 0.5rem 0; font-size: 1.2rem; }
        .cite-link { color: var(--primary-color); font-weight: 600; text-decoration: none; transition: color 0.2s; }
        .cite-link:hover { color: var(--primary-hover); text-decoration: underline; }
        .code-showcase h3 { color: var(--heading-color); font-size: 1.4rem; margin-bottom: 1rem; }
        .tabs { display: flex; flex-wrap: wrap; border-bottom: 2px solid var(--border-color); }
        .tab-button { padding: 14px 20px; cursor: pointer; background: none; color: #6c757d; border: none; font-size: 1rem; font-weight: 500; transition: all 0.2s; border-bottom: 3px solid transparent; margin-bottom: -2px; }
        .tab-button.active, .tab-button:hover { color: var(--primary-color); border-bottom: 3px solid var(--primary-color); }
        .code-content { display: none; padding: 1.5rem; background: var(--code-bg); color: var(--code-text); border-radius: 0 0 8px 8px; height: 450px; overflow-y: auto; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; white-space: pre; font-size: 0.9rem; border: 1px solid var(--border-color); border-top: none; }
        .code-content.active { display: block; }
        .compiler-controls { display: flex; gap: 1rem; align-items: center; margin-bottom: 1.5rem; }
        #test-selector { flex-grow: 1; padding: 14px; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background-color: #fff; transition: border-color 0.2s, box-shadow 0.2s; }
        #test-selector:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.25); }
        .run-button { padding: 14px 28px; font-size: 1.1rem; font-weight: 600; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; }
        .run-button:hover { background: #218838; transform: translateY(-1px); }
        .run-button:disabled { background: #aaa; cursor: not-allowed; }
        #output { background: #212529; color: #50E3C2; padding: 1.5rem; border-radius: 8px; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; white-space: pre-wrap; min-height: 50px; }
        footer { text-align: center; padding: 2.5rem; color: #6c757d; }
    </style>
</head>
<body>

    <header>
        <h1>Efficient Memory Allocation in C</h1>
        <p>A Project by Yashvin Jasani</p>
    </header>

    <div class="container">
        <section class="section overview-section fade-in-section">
            <h2>Project Overview</h2>
            <div class="content-wrapper">
                <h3>Real-World Application & Use Cases</h3>
                <p>
                    In high-performance computing, standard memory allocators like `malloc()` can become a bottleneck. This project demonstrates the ability to solve this by building a custom, efficient memory allocator from the ground up. Such specialized allocators are critical in fields like <strong>game development</strong>, <strong>real-time operating systems</strong>, and <strong>embedded systems</strong>, where predictable performance and low-latency memory management are paramount.
                </p>
                <h3>Project Implementation in Brief</h3>
                <p>
                    This allocator, implemented in C, manages a 4096-byte static memory pool using a <strong>header-based, first-fit algorithm</strong>. To combat fragmentation, the `myfree()` implementation includes a <strong>coalescing mechanism</strong> that merges adjacent free blocks, maximizing memory availability for future allocations.
                </p>
                <h3>Comprehensive Testing & Stress Analysis</h3>
                <p>
                    To ensure correctness and robustness, the allocator was subjected to a rigorous testing regimen:
                </p>
                <div class="test-desc">
                    <h4>Correctness & Edge Cases:</h4>
                    <p>A suite of targeted tests validates core requirements, as seen in <a href="#code-showcase-section" class="cite-link" data-tab-name="Test1_c" data-tab-container="test-tabs">Test 1</a>, <a href="#code-showcase-section" class="cite-link" data-tab-name="Test4_2_c" data-tab-container="test-tabs">Test 4 (Part 2)</a>, and <a href="#code-showcase-section" class="cite-link" data-tab-name="Test5_c" data-tab-container="test-tabs">Test 5</a>. This suite ensures no memory overlap, proper deallocation, robust error handling, and automated memory leak detection.</p>
                </div>
                 <div class="test-desc">
                    <h4>Performance & Stress Testing:</h4>
                    <p>The <a href="#code-showcase-section" class="cite-link" data-tab-name="memgrind_c" data-tab-container="test-tabs">Stress Test (memgrind)</a> program analyzes performance under various workloads. Each demanding workload was executed 50 times, with tests involving up to 120 allocation/deallocation cycles per run to measure efficiency and reliability under stress.</p>
                </div>
            </div>
        </section>

        <section id="code-showcase-section" class="section code-showcase fade-in-section">
            <h2>Code Files</h2>
            <h3>Core Files</h3>
            <div class="tabs" id="core-tabs">
                <button class="tab-button active" onclick="openTab(event, 'mymalloc_c', 'core-tabs')">My Malloc</button>
                <button class="tab-button" onclick="openTab(event, 'mymalloc_h', 'core-tabs')">My Malloc Header</button>
                <button class="tab-button" onclick="openTab(event, 'Makefile', 'core-tabs')">Makefile</button>
            </div>
            <div id="mymalloc_c" class="code-content active">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "mymalloc.h"

#define MEMLENGTH 4096

static union {
    char bytes[MEMLENGTH];
    double not_used; 
} heap;

typedef struct header {
        int size; // size of the chunk 
        int is_allocated; // if 0 empty if 1 full
} header; 

static int initialized = 0;
static header *head = NULL;
void leak_report();

void allocation(){
    if(!initialized){
        head = (header*) heap.bytes;
        head -&gt; size = MEMLENGTH - sizeof(header);  
        head -&gt; is_allocated = 0;  
        initialized = 1;   
        atexit(leak_report);
    }
}

void * mymalloc(size_t size, char *file, int line){
    allocation();
    header *current = head;
    if((size % 8) != 0){
        size = size + (8 - (size % 8));
    }
    while ((char*)current &lt; heap.bytes + MEMLENGTH) {
        if((current -&gt; is_allocated) == 0 && current -&gt; size &gt;= size){
            int old_size = current-&gt;size;
            current -&gt; size = size;
            current -&gt; is_allocated = 1;
            header *temp = current; 
            if((old_size) &gt; (size + sizeof(header))){
                header *next = (header *) ((char *)current + sizeof(header) + size);
                next -&gt; size = old_size - size - sizeof(header);
                next -&gt; is_allocated = 0;
            }
            return (void*) ((char*)temp + sizeof(header));
        }
        current = (header *)((char *)current + (sizeof(header)) + current -&gt; size);
    }
    fprintf(stderr, "malloc: Unable to allocate %zu bytes (%s:%d)\n", size, file, line);
    return NULL;
}

void myfree(void *ptr, char *file, int line){
    allocation();
    if(!ptr){ return; }
    if ((char*)ptr &lt; (heap.bytes + sizeof(header)) || (char*)ptr &gt;= (heap.bytes + MEMLENGTH)) {
        fprintf(stderr, "free: Inappropriate pointer (%s:%d)\n", file, line);
        exit(2);
    }
    header *r = head;
    int is_in = 0;
    while((char*)r &lt; heap.bytes + MEMLENGTH){
        if ((char*)r + sizeof(header) == (char*)ptr){
            is_in = 1;
            break;
        }
        r = (header *)((char*)r + sizeof(header) + r -&gt; size);
    }
    if(!is_in){
        fprintf(stderr, "free: Inappropriate pointer (%s:%d)\n", file, line);
        exit(2);
    }
    header *chunk = (header *)((char *) ptr - sizeof(header));
    if (chunk -&gt; is_allocated == 0) {
        fprintf(stderr, "free: Inappropriate pointer (%s:%d)\n", file, line);
        exit(2);
    }
    chunk -&gt; is_allocated = 0;
    header *c = (header*) heap.bytes; 
    header *p = NULL;
    while((char*)c &lt; (char*)chunk){
        p = c;
        c = (header *)((char *)p + sizeof(header) + p -&gt; size );
    }
    if(p != NULL && p-&gt;is_allocated == 0){            
        p -&gt;size += chunk -&gt; size + sizeof(header);      
        chunk = p;        
    }
    header *next = (header *) ((char *)(chunk) + sizeof(header) + chunk -&gt; size);
    while ((char*)next &lt; heap.bytes + MEMLENGTH - sizeof(header) && next-&gt;is_allocated == 0) {
        if (((char *)next &gt;= heap.bytes + MEMLENGTH)){ break; }
        chunk -&gt; size += sizeof(header) + next -&gt; size;
        next = (header *) ((char *)(chunk) + sizeof(header) + chunk -&gt; size);
    }
}

void leak_report(){
    header *h = head;
    int memory = 0;
    int chunks = 0;
    while((char*)h &lt; heap.bytes + MEMLENGTH){
        if(h -&gt; is_allocated == 1){
            memory += h -&gt; size;
            chunks += 1;
        }
        h = (header *)((char *)h + sizeof(header) + h -&gt; size );
    }
    if(chunks &gt; 0){
        fprintf(stderr, "mymalloc: %d bytes leaked in %d objects\n", memory, chunks);
    }
}</div>
            <div id="mymalloc_h" class="code-content">#ifndef _MYMALLOC_H
#define _MYMALLOC_H

#define malloc(X) mymalloc(X, __FILE__, __LINE__)
#define free(X) myfree(X, __FILE__, __LINE__)

void * mymalloc(size_t size, char *file, int line);
void   myfree(void *ptr, char *file, int line);

#endif</div>
            <div id="Makefile" class="code-content">all: memgrind memtest Test1 Test2 Test3 Test4_1 Test4_2 Test4_3 Test5
memgrind: memgrind.o mymalloc.o
	gcc memgrind.o mymalloc.o -o memgrind
memtest: memtest.o mymalloc.o
	gcc memtest.o mymalloc.o -o memtest
Test1: Test1.o mymalloc.o
	gcc Test1.o mymalloc.o -o Test1
Test2: Test2.o mymalloc.o
	gcc Test2.o mymalloc.o -o Test2
Test3: Test3.o mymalloc.o
	gcc Test3.o mymalloc.o -o Test3
Test4_1: Test4_1.o mymalloc.o
	gcc Test4_1.o mymalloc.o -o Test4_1
Test4_2: Test4_2.o mymalloc.o
	gcc Test4_2.o mymalloc.o -o Test4_2
Test4_3: Test4_3.o mymalloc.o
	gcc Test4_3.o mymalloc.o -o Test4_3
Test5: Test5.o mymalloc.o
	gcc Test5.o mymalloc.o -o Test5
mymalloc.o: mymalloc.c mymalloc.h
	gcc -c mymalloc.c
memgrind.o: memgrind.c mymalloc.h
	gcc -c memgrind.c
memtest.o: memtest.c mymalloc.h
	gcc -c memtest.c
Test1.o: Test1.c mymalloc.h
	gcc -c Test1.c
Test2.o: Test2.c mymalloc.h
	gcc -c Test2.c
Test3.o: Test3.c mymalloc.h
	gcc -c Test3.c
Test4_1.o: Test4_1.c mymalloc.h
	gcc -c Test4_1.c
Test4_2.o: Test4_2.c mymalloc.h
	gcc -c Test4_2.c
Test4_3.o: Test4_3.c mymalloc.h
	gcc -c Test4_3.c
Test5.o: Test5.c mymalloc.h
	gcc -c Test5.c
clean:
	rm -f *.o mymalloc memgrind memtest Test1 Test2 Test3 Test4_1 Test4_2 Test4_3 Test5</div>

            <h3 style="margin-top: 2rem;">Test Files</h3>
            <div class="tabs" id="test-tabs">
                <button class="tab-button active" onclick="openTab(event, 'Test1_c', 'test-tabs')">Test 1</button>
                <button class="tab-button" onclick="openTab(event, 'Test2_c', 'test-tabs')">Test 2</button>
                <button class="tab-button" onclick="openTab(event, 'Test3_c', 'test-tabs')">Test 3</button>
                <button class="tab-button" onclick="openTab(event, 'Test4_1_c', 'test-tabs')">Test 4 (Part 1)</button>
                <button class="tab-button" onclick="openTab(event, 'Test4_2_c', 'test-tabs')">Test 4 (Part 2)</button>
                <button class="tab-button" onclick="openTab(event, 'Test4_3_c', 'test-tabs')">Test 4 (Part 3)</button>
                <button class="tab-button" onclick="openTab(event, 'Test5_c', 'test-tabs')">Test 5</button>
                <button class="tab-button" onclick="openTab(event, 'memgrind_c', 'test-tabs')">Stress Test (memgrind)</button>
                <button class="tab-button" onclick="openTab(event, 'memtest_c', 'test-tabs')">Memory Test (memtest)</button>
            </div>
            <div id="Test1_c" class="code-content active">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    char *a = malloc(500);
    memset(a, 'A', 500);
    char *b = malloc(500);
    memset(b, 'B', 500);
    char *c = malloc(500);
    memset(c, 'C', 500);
    int overlap = 0;
    for(int i = 0; i &lt; 500; i++){
        if(a[i] != 'A' || b[i] != 'B' || c[i] != 'C'){
            overlap = 1;
            break;
        }
    }
    if(overlap == 1){
        printf("Overlap Detected\n");
    }else {
        printf("No Overlap Detected\n");
    }
    free(a);
    free(b);
    free(c);
    return 0;
}</div>
            <div id="Test2_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    char *p = malloc(4000);
    free(p);
    char *p2 = malloc(2000);
    free(p2);
    return 0;
}</div>
            <div id="Test3_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    char *a1 = malloc(1000);
    char *a2 = malloc(1000);
    char *a3 = malloc(1000);
    char *a4 = malloc(1000);
    free(a1);
    free(a2);
    char *a5 = malloc(2000);
    free(a5);
    free(a3);
    free(a4);
    return 0;
}</div>
            <div id="Test4_1_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    char *a = malloc(1000);
    int x;
    free(&x);
    return 0;
}</div>
            <div id="Test4_2_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    int *a1 = malloc(sizeof(int) * 2);
    free(a1 + 1);
    return 0;
}</div>
            <div id="Test4_3_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    char *a2 = malloc(1000);
    char *q = a2;
    free(a2);
    free(q);
    return 0;
}</div>
            <div id="Test5_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "mymalloc.h"
int main(){
    char *a1 = malloc(500);
    char *a2 = malloc(1500);
    free(a1);
    return 0;
}</div>
            <div id="memgrind_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/time.h&gt;
#include "mymalloc.h"
typedef struct Node { int value; struct Node *next; } Node;
typedef struct Tree { int value; struct Tree *right; struct Tree *left; } Tree;
void freeTree(Tree *root){
    if(!root){ return; }
    freeTree(root -&gt; left);
    freeTree(root -&gt; right);
    free(root);
}
int main(){
    struct timeval start, end;
    long seconds, useconds;
    gettimeofday(&start, NULL);
    for(int t = 0; t &lt; 50; t++){
        for(int i = 0; i &lt; 120; i++){
            char *a = malloc(1);
            if(a == NULL){ fprintf(stderr, "Memory allocation failed"); continue; }
            free(a);
        }
    }
    gettimeofday(&end, NULL);
    seconds = end.tv_sec  - start.tv_sec;
    useconds = end.tv_usec - start.tv_usec;
    double time = (seconds * 1000000.0 + useconds) / 1000000.0;
    double avg_time = time/50;
    printf("The average time for first workload is %1.8f seconds.\n", avg_time);
    gettimeofday(&start, NULL);
    for(int t = 0; t &lt; 50; t++){
        char *p[120];
        for(int i = 0; i &lt; 120; i++){
            p[i] = malloc(1);
            if(p[i] == NULL){ fprintf(stderr, "Memory allocation failed"); continue; }            
        }
        for(int i = 0; i &lt; 120; i++){ free(p[i]); }
    }
    gettimeofday(&end, NULL);
    seconds = end.tv_sec  - start.tv_sec;
    useconds = end.tv_usec - start.tv_usec;
    double time2 = (seconds * 1000000.0 + useconds) / 1000000.0;
    double avg_time2 = time2 / 50;
    printf("The average time for second workload is %1.8f seconds.\n", avg_time2);
    gettimeofday(&start, NULL);
    for(int t = 0; t &lt; 50; t++){
        char *q[120];
        int alreay_free[120] = {0};
        int up = 3, low = 0;
        for(int i = 0; i &lt; 120; i++){
            q[i] = malloc(1);
            if(i == up){ 
                for(int j = low; j &lt; i; j++){
                    int random = (rand() % (up - 0 + 1)) + 0;
                    if(alreay_free[random] == 0){ free(q[random]); alreay_free[random] = 1; }
                }
                int random2 = (rand() % (4 - 1 + 1)) + 1;
                low = up; 
                up += random2;
            }
        }
        for(int i = 0; i &lt; 120; i++){
            if(alreay_free[i] == 0){ free(q[i]); }
        }
    }
    gettimeofday(&end, NULL);
    seconds = end.tv_sec  - start.tv_sec;
    useconds = end.tv_usec - start.tv_usec;
    double time3 = (seconds * 1000000.0 + useconds) / 1000000.0;
    double avg_time3 = time3 / 50;
    printf("The average time for third workload is %1.8f seconds.\n", avg_time3);
    gettimeofday(&start, NULL);
    for(int j = 0; j &lt; 50; j++){
        Node *head = NULL;
        for (int i = 0; i &lt; 100; i++) {
            Node* node = (Node*)malloc(sizeof(Node));
            node -&gt; value = 10;
            node -&gt; next = head;
            head = node;
        }
        while(head != NULL){
            Node *next = head -&gt; next;
            free(head);
            head = next;
        }
    }
    gettimeofday(&end, NULL);
    seconds = end.tv_sec  - start.tv_sec;
    useconds = end.tv_usec - start.tv_usec;
    double time4 = (seconds * 1000000.0 + useconds) / 1000000.0;
    double avg_time4 = time4/50;
    printf("The average time for fourth workload is %1.8f seconds.\n", avg_time4);
    gettimeofday(&start, NULL);
    for(int j = 0; j &lt; 50; j++){
        Tree* nodes[100];
        for(int i = 0; i &lt; 100; i++){
            nodes[i] = malloc(sizeof(Tree));
            nodes[i]  -&gt; value = i;
            nodes[i] -&gt; left = NULL;
            nodes[i] -&gt; right = NULL;
        }
        for(int i = 0; i &lt; 100; i++){
            int left = (i * 2) + 1;
            int right = (i * 2) + 2;
            if(left &lt; 100){ nodes[i]  -&gt; left = nodes[left]; }
            if(right &lt; 100){ nodes[i]  -&gt; right = nodes[right]; }
        }
        freeTree(nodes[0]);
    }
    gettimeofday(&end, NULL);
    seconds = end.tv_sec  - start.tv_sec;
    useconds = end.tv_usec - start.tv_usec;
    double time5 = (seconds * 1000000.0 + useconds) / 1000000.0;
    double avg_time5 = time5/50;
    printf("The average time for fifth workload is %1.8f seconds.\n", avg_time5);
    return 0;
}</div>
            <div id="memtest_c" class="code-content">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#ifndef REALMALLOC
#include "mymalloc.h"
#endif
#ifndef LEAK
#define LEAK 0
#endif
#define MEMSIZE 4096
#define HEADERSIZE 8
#define OBJECTS 64
#define OBJSIZE (MEMSIZE / OBJECTS - HEADERSIZE)
int main(int argc, char **argv)
{
	char *obj[OBJECTS];
	int i, j, errors = 0;
	for (i = 0; i &lt; OBJECTS; i++) {
		obj[i] = malloc(OBJSIZE);
		if (obj[i] == NULL) {
		    printf("Unable to allocate object %d\n", i);
		    exit(1);
		}
	}
	for (i = 0; i &lt; OBJECTS; i++) {
		memset(obj[i], i, OBJSIZE);
	}
	for (i = 0; i &lt; OBJECTS; i++) {
		for (j = 0; j &lt; OBJSIZE; j++) {
			if (obj[i][j] != i) {
				errors++;
				printf("Object %d byte %d incorrect: %d\n", i, j, obj[i][j]);
			}
		}
	}
	if (!LEAK) {
	    for (i = 0; i &lt; OBJECTS; i++) {
		    free(obj[i]);
	    }
	}
	printf("%d incorrect bytes\n", errors);
	return EXIT_SUCCESS;
}</div>
        </section>

        <section class="section fade-in-section">
            <h2>Live Demo</h2>
            <p>Select a test case from the dropdown and click "Compile & Run". This interactive demo uses a WebAssembly-based C compiler (TCC-JS) to compile and run your code directly in the browser.</p>
            <div class="compiler-controls">
                <select id="test-selector">
                    <option value="Test1_c">Test 1</option>
                    <option value="Test2_c">Test 2</option>
                    <option value="Test3_c">Test 3</option>
                    <option value="Test4_1_c">Test 4 (Part 1)</option>
                    <option value="Test4_2_c">Test 4 (Part 2)</option>
                    <option value="Test4_3_c">Test 4 (Part 3)</option>
                    <option value="Test5_c">Test 5</option>
                    <option value="memgrind_c">Stress Test (memgrind)</option>
                    <option value="memtest_c">Memory Test (memtest)</option>
                </select>
                <button id="runBtn" class="run-button">Compile & Run</button>
            </div>
            <h3>Output:</h3>
            <pre id="output">Compiler output will appear here...</pre>
        </section>
    </div>

    <footer>
        <p>Interactive project showcase for Yashvin Jasani</p>
    </footer>

    <script>
        function openTab(evt, tabName, tabContainerId) {
            const tabContainer = document.getElementById(tabContainerId).parentElement;
            const tabcontent = tabContainer.querySelectorAll('.code-content');
            tabcontent.forEach(tc => tc.style.display = 'none');
            const tabbuttons = document.getElementById(tabContainerId).querySelectorAll('.tab-button');
            tabbuttons.forEach(tb => tb.classList.remove('active'));
            document.getElementById(tabName).style.display = 'block';
            evt.currentTarget.classList.add('active');
        }

        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('cite-link')) {
                e.preventDefault();
                const tabName = e.target.dataset.tabName;
                const tabContainerId = e.target.dataset.tabContainer;
                const tabButtons = document.getElementById(tabContainerId).querySelectorAll('.tab-button');
                for (let btn of tabButtons) {
                    if (btn.getAttribute('onclick').includes(`'${tabName}'`)) {
                        btn.click();
                        break;
                    }
                }
                document.getElementById('code-showcase-section').scrollIntoView({ behavior: 'smooth' });
            }
        });

        document.addEventListener("DOMContentLoaded", function() {
            document.querySelector('#core-tabs .tab-button').click();
            document.querySelector('#test-tabs .tab-button').click();

            const sections = document.querySelectorAll('.fade-in-section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                    }
                });
            }, { threshold: 0.1 });
            sections.forEach(section => { observer.observe(section); });

            const runButton = document.getElementById('runBtn');
            const outputDiv = document.getElementById('output');
            const selector = document.getElementById('test-selector');
            let tcc;

            // Initialize the TCC compiler
            TCC.initialize().then(instance => {
                tcc = instance;
                runButton.disabled = false;
                outputDiv.innerText = "Compiler is ready. Select a test and run.";
            }).catch(err => {
                 outputDiv.innerText = "Failed to initialize the in-browser compiler.";
                 console.error(err);
            });

            runButton.onclick = async () => {
                if (!tcc) {
                    outputDiv.innerText = "Compiler is not ready. Please wait.";
                    return;
                }
                runButton.disabled = true;
                runButton.innerText = 'Compiling...';
                outputDiv.innerText = 'Compiling code in browser...';

                const mymalloc_h_code = document.getElementById('mymalloc_h').innerText;
                const mymalloc_c_code = document.getElementById('mymalloc_c').innerText.replace(/#include "mymalloc.h"/g, '');
                const selectedTestId = selector.value;
                const test_file_code = document.getElementById(selectedTestId).innerText.replace(/#include "mymalloc.h"/g, '');

                const full_source_code = mymalloc_h_code + "\n" + mymalloc_c_code + "\n" + test_file_code;
                
                try {
                    const compilationResult = tcc.compile(full_source_code);
                    if (compilationResult.byteLength > 0) {
                        outputDiv.innerText = 'Compilation successful. Running...';
                        const { stdout, stderr, exit_code } = await tcc.run(compilationResult, []);
                        let output = `--- Program Output (stdout) ---\n${stdout || '(no output)'}\n\n`;
                        output += `--- Program Errors (stderr) ---\n${stderr || '(no errors)'}\n\n`;
                        output += `--- Exit Code: ${exit_code} ---`;
                        outputDiv.innerText = output;
                    } else {
                        outputDiv.innerText = `--- Compilation Failed ---\n${tcc.log}`;
                    }
                } catch (e) {
                    outputDiv.innerText = `An unexpected error occurred during compilation or execution:\n${e.message}`;
                } finally {
                    runButton.disabled = false;
                    runButton.innerText = 'Compile & Run';
                }
            };
        });
    </script>
</body>
</html>
